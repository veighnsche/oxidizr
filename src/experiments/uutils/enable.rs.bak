use crate::error::{CoreutilsError, Result};
use crate::utils::worker::Worker;
use crate::experiments::uutils::constants::{COREUTILS_UNIFIED_PATH, COREUTILS_UNIFIED_CANDIDATES, COREUTILS_BINS_LIST, SYSTEM_BIN_DIR};
use crate::experiments::uutils::model::UutilsExperiment;
use crate::experiments::uutils::utils::resolve_target;
use std::path::{Path, PathBuf};
use std::fs;

impl UutilsExperiment {
    /// Enables the uutils experiment by installing the package and setting up symlinks.
    pub fn enable<W: Worker>(&self, worker: &W, _assume_yes: bool, update_lists: bool) -> Result<()> {
        if !self.check_compatible(worker)? {
            return Err(CoreutilsError::Incompatible("Unsupported Arch release".into()));
        }
        if update_lists { log::info!("Updating package lists..."); worker.update_packages()?; }

        log::info!("Installing package: {}", self.package);
        worker.install_package(&self.package)?;

        let applets = if self.name == "coreutils" {
            self.handle_coreutils_applets(worker)?
        } else {
            self.handle_non_coreutils_applets(worker)?
        };

        if applets.is_empty() {
            return Err(CoreutilsError::ExecutionFailed(format!(
                "No applets selected for family '{}' (bin_directory: {}). This usually means the package did not install binaries in expected locations. \
                 Hints: ensure '{}' is installed; verify presence under {} or cargo-style /usr/lib/cargo/bin/<family>/.",
                self.name,
                self.bin_directory.display(),
                self.package,
                self.bin_directory.display()
            )));
        }

        self.log_applets_summary(&applets);
        self.create_symlinks(worker, &applets)
    }

    /// Handles applet collection for coreutils family.
    fn handle_coreutils_applets<W: Worker>(&self, worker: &W) -> Result<Vec<(String, PathBuf)>> {
        let unified_path = self.resolve_unified_coreutils_path(worker);
        if Path::new(if cfg!(test) { "bin/coreutils" } else { COREUTILS_UNIFIED_PATH }).exists() {
            log::info!("Using unified coreutils binary at: {}", if cfg!(test) { "bin/coreutils" } else { COREUTILS_UNIFIED_PATH });
            Ok(self.collect_applets_with_unified_dispatcher(worker))
        } else {
            log::warn!(
                "Unified dispatcher not available; falling back to per-applet binaries under {}",
                self.bin_directory.display()
            );
            Ok(self.collect_applets_per_binary(worker))
        }
    }

    /// Resolves the path to the unified coreutils binary.
    fn resolve_unified_coreutils_path<W: Worker>(&self, worker: &W) -> PathBuf {
        if let Some(cfg) = &self.unified_binary {
            if cfg.exists() {
                return cfg.clone();
            } else if let Ok(Some(found)) = worker.which("coreutils") {
                return found;
            }
        } else if let Ok(Some(found)) = worker.which("coreutils") {
            return found;
        }

        let default_path = if cfg!(test) {
            PathBuf::from("bin/coreutils")
        } else {
            PathBuf::from(COREUTILS_UNIFIED_PATH)
        };
        if !default_path.exists() {
            if let Some(found) = COREUTILS_UNIFIED_CANDIDATES.iter().map(|p| if cfg!(test) { PathBuf::from("bin").join(p.trim_start_matches('/')) } else { PathBuf::from(p) }).find(|p| p.exists()) {
                log::warn!(
                    "Unified coreutils not found at {}; creating symlink {} -> {}",
                    default_path.display(),
                    if cfg!(test) { "bin/coreutils" } else { COREUTILS_UNIFIED_PATH },
                    found.display()
                );
                let target_dir = if cfg!(test) { Path::new("bin") } else { Path::new(SYSTEM_BIN_DIR) };
                let _ = std::fs::create_dir_all(target_dir);
                let target_path = if cfg!(test) { PathBuf::from("bin/coreutils") } else { PathBuf::from(COREUTILS_UNIFIED_PATH) };
                let _ = std::fs::remove_file(&target_path);
                if let Err(e) = std::os::unix::fs::symlink(&found, &target_path) {
                    log::error!("Failed to create {} symlink: {}", target_path.display(), e);
                } else {
                    log::info!("Created {} symlink to {}", target_path.display(), found.display());
                }
            } else {
                log::warn!(
                    "Unified coreutils binary not found in any known location: will error if not present after this step"
                );
            }
        }
        default_path
    }

    /// Collects applets using a unified dispatcher binary.
    fn collect_applets_with_unified_dispatcher<W: Worker>(&self, worker: &W) -> Vec<(String, PathBuf)> {
        let mut applets = Vec::new();
        for line in COREUTILS_BINS_LIST.lines() {
            let name = line.trim();
            if name.is_empty() { continue; }
            if name == "tsor" {
                if let Ok(Some(tsort_target)) = worker.which("tsort") {
                    applets.push(("tsor".to_string(), tsort_target));
                    continue;
                }
                if let Ok(Some(tsor_target)) = worker.which("tsor") {
                    applets.push(("tsor".to_string(), tsor_target));
                    continue;
                }
                applets.push(("tsor".to_string(), if cfg!(test) { PathBuf::from("bin/coreutils") } else { PathBuf::from(COREUTILS_UNIFIED_PATH) }));
                continue;
            }
            if name == "arch" {
                applets.push((name.to_string(), if cfg!(test) { PathBuf::from("bin/coreutils") } else { PathBuf::from(COREUTILS_UNIFIED_PATH) }));
                continue;
            }
            applets.push((name.to_string(), if cfg!(test) { PathBuf::from("bin/coreutils") } else { PathBuf::from(COREUTILS_UNIFIED_PATH) }));
        }
        applets
    }

    /// Collects applets by linking to individual binaries.
    fn collect_applets_per_binary<W: Worker>(&self, worker: &W) -> Vec<(String, PathBuf)> {
        let mut applets = Vec::new();
        for line in COREUTILS_BINS_LIST.lines() {
            let name = line.trim();
            if name.is_empty() { continue; }
            let (probe_name, link_as) = if name == "tsor" { ("tsort", "tsor") } else { (name, name) };
            if link_as == "arch" {
                let candidates = self.get_coreutils_candidates(probe_name);
                if let Some(found) = candidates.iter().find(|p| p.exists()) {
                    log::info!(
                        "Per-applet source selected for '{}': {}",
                        link_as,
                        found.display()
                    );
                    applets.push((link_as.to_string(), found.clone()));
                } else {
                    log::warn!(
                        "Per-applet binary for 'arch' not found in any known location; using fallback path"
                    );
                    // Use a relative path in test mode
                    let fallback_path = if cfg!(test) {
                        PathBuf::from("bin/uu-arch")
                    } else {
                        PathBuf::from("/usr/bin/uu-arch")
                    };
                    applets.push((link_as.to_string(), fallback_path));
                }
                continue;
            }
            if worker.which(link_as).unwrap_or(None).is_none() {
                log::debug!("Skipping '{}' (no discoverable target via which)", link_as);
                continue;
            }
            let candidates = self.get_coreutils_candidates(probe_name);
            if let Some(found) = candidates.iter().find(|p| p.exists()) {
                log::info!(
                    "Per-applet source selected for '{}': {}",
                    link_as,
                    found.display()
                );
                applets.push((link_as.to_string(), found.clone()));
            } else {
                log::warn!(
                    "Per-applet binary for '{}' not found in any known location; skipping",
                    link_as
                );
            }
        }
        applets
    }

    /// Gets candidate paths for coreutils binaries.
    fn get_coreutils_candidates(&self, probe_name: &str) -> [PathBuf; 4] {
        if cfg!(test) {
            [
                self.bin_directory.join(probe_name),
                PathBuf::from(format!("bin/uu-{}", probe_name)),
                PathBuf::from(format!("bin/coreutils/{}", probe_name)),
                PathBuf::from(format!("bin/{}", probe_name)),
            ]
        } else {
            [
                self.bin_directory.join(probe_name),
                PathBuf::from(format!("/usr/bin/uu-{}", probe_name)),
                PathBuf::from(format!("/usr/lib/cargo/bin/coreutils/{}", probe_name)),
                PathBuf::from(format!("/usr/lib/cargo/bin/{}", probe_name)),
            ]
        }
    }

    /// Handles applet collection for non-coreutils families.
    fn handle_non_coreutils_applets<W: Worker>(&self, worker: &W) -> Result<Vec<(String, PathBuf)>> {
        log::info!(
            "Preparing applets for family '{}' under {}",
            self.name,
            self.bin_directory.display()
        );
        let mut applets = Vec::new();
        let existing = worker.list_files(&self.bin_directory)?;
        if !existing.is_empty() {
            for f in existing {
                let filename = f.file_name().and_then(|s| s.to_str()).unwrap_or("").to_string();
                if filename.is_empty() { continue; }
                applets.push((filename, f.clone()));
            }
        } else {
            let known: &[&str] = match self.name.as_str() {
                "findutils" => &["find", "xargs"],
                _ => &[],
            };
            if known.is_empty() {
                log::warn!(
                    "No applets declared for family '{}' and no files under {}",
                    self.name,
                    self.bin_directory.display()
                );
            }
            if let Some(parent) = self.bin_directory.parent() {
                let _ = std::fs::create_dir_all(parent);
            }
            let _ = std::fs::create_dir_all(&self.bin_directory);
            for name in known {
                let candidates = self.get_non_coreutils_candidates(name);
                if let Some(real) = candidates.iter().find(|p| p.exists()) {
                    let canonical_src = self.bin_directory.join(name);
                    if canonical_src.exists() {
                        let _ = std::fs::remove_file(&canonical_src);
                    }
                    match std::fs::copy(real, &canonical_src) {
                        Ok(_) => {
                            if let Ok(meta) = std::fs::metadata(real) {
                                let perm = meta.permissions();
                                let _ = std::fs::set_permissions(&canonical_src, perm);
                            }
                            log::info!(
                                "Synthesized canonical source (copied) {} <- {}",
                                canonical_src.display(),
                                real.display()
                            );
                            applets.push((name.to_string(), canonical_src));
                        }
                        Err(e) => {
                            log::warn!(
                                "Failed to copy {} to canonical source {}: {}",
                                real.display(),
                                canonical_src.display(),
                                e
                            );
                        }
                    }
                } else {
                    log::warn!(
                        "No binary found for '{}' in known locations for family '{}'",
                        name,
                        self.name
                    );
                }
            }
            if applets.is_empty() {
                return Err(CoreutilsError::ExecutionFailed(
                    format!(
                        "No '{}' applet binaries found or synthesized under {}. \
                         Ensure '{}' installed correctly; if installed via AUR, verify that the helper completed successfully.",
                        self.name, self.bin_directory.display(), self.package
                    )
                ));
            }
        }
        Ok(applets)
    }

    /// Gets candidate paths for non-coreutils binaries.
    fn get_non_coreutils_candidates(&self, name: &str) -> [PathBuf; 4] {
        if cfg!(test) {
            [
                PathBuf::from(format!("bin/uu-{}", name)),
                PathBuf::from(format!("bin/{}/{}", self.name, name)),
                PathBuf::from(format!("bin/{}", name)),
                PathBuf::from(format!("bin/{}", name)),
            ]
        } else {
            [
                PathBuf::from(format!("/usr/bin/uu-{}", name)),
                PathBuf::from(format!("/usr/lib/cargo/bin/{}/{}", self.name, name)),
                PathBuf::from(format!("/usr/lib/cargo/bin/{}", name)),
                PathBuf::from(format!("/usr/bin/{}", name)),
            ]
        }
    }

    /// Logs a summary of the applets to be linked.
    fn log_applets_summary(&self, applets: &[(String, PathBuf)]) {
        log::info!(
            "Preparing to link {} applet(s) for '{}' (package: {})",
            applets.len(), self.name, self.package
        );
        for (i, (filename, src)) in applets.iter().enumerate().take(8) {
            let target = resolve_target(worker, filename);
            log::info!("  [{}] {} -> {}{}", i + 1, src.display(), target.display(), if i + 1 == 8 && applets.len() > 8 { " (…truncated)" } else { "" });
        }
    }

    /// Creates symlinks for the selected applets.
    fn create_symlinks<W: Worker>(&self, worker: &W, applets: &[(String, PathBuf)]) -> Result<()> {
        for (filename, src) in applets {
            let target = resolve_target(worker, filename);
            let src_exists = src.exists();
            let tgt_exists = target.exists();
            log::info!(
                "Symlinking {} -> {} (src_exists={}, target_exists={})",
                src.display(), target.display(), src_exists, tgt_exists
            );
            worker.replace_file_with_symlink(src, &target)?;
        }
        Ok(())
    }
}
