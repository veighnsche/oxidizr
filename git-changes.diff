diff --git a/cargo/switchyard/src/adapters/lock/file.rs b/cargo/switchyard/src/adapters/lock/file.rs
index a00899a..f7f911e 100644
--- a/cargo/switchyard/src/adapters/lock/file.rs
+++ b/cargo/switchyard/src/adapters/lock/file.rs
@@ -9,6 +9,7 @@ use fs2::FileExt;
 
 use super::{LockGuard, LockManager};
 
+#[derive(Debug)]
 pub struct FileLockManager {
     path: PathBuf,
 }
diff --git a/cargo/switchyard/src/api/apply/lock.rs b/cargo/switchyard/src/api/apply/lock.rs
index 6eb8b74..54a2152 100644
--- a/cargo/switchyard/src/api/apply/lock.rs
+++ b/cargo/switchyard/src/api/apply/lock.rs
@@ -99,8 +99,8 @@ pub(crate) fn acquire<E: FactsEmitter, A: AuditSink>(
                 })).emit_failure();
                 let duration_ms = t0.elapsed().as_millis() as u64;
                 return LockInfo {
-                    lock_backend,
-                    lock_wait_ms,
+                    lock_backend: "none".to_string(),
+                    lock_wait_ms: None,
                     approx_attempts: 0,
                     guard: None,
                     early_report: Some(ApplyReport {
@@ -112,19 +112,7 @@ pub(crate) fn acquire<E: FactsEmitter, A: AuditSink>(
                         rollback_errors: Vec::new(),
                     }),
                 };
-            } else {
-                StageLogger::new(tctx).apply_attempt().merge(json!({
-                    "lock_backend": "none",
-                    "no_lock_manager": true,
-                    "lock_attempts": 0u64,
-                })).emit_warn();
             }
-        } else {
-            StageLogger::new(tctx).apply_attempt().merge(json!({
-                "lock_backend": "none",
-                "no_lock_manager": true,
-                "lock_attempts": 0u64,
-            })).emit_warn();
         }
     }
 
diff --git a/cargo/switchyard/src/api/apply/mod.rs b/cargo/switchyard/src/api/apply/mod.rs
index 5675dd0..cd9718d 100644
--- a/cargo/switchyard/src/api/apply/mod.rs
+++ b/cargo/switchyard/src/api/apply/mod.rs
@@ -49,7 +49,7 @@ pub(crate) fn run<E: FactsEmitter, A: AuditSink>(
     // Audit context
     let run_id = new_run_id();
     let tctx = AuditCtx::new(
-        &api.facts as &dyn FactsEmitter,
+        &api.facts,
         pid.to_string(),
         run_id,
         ts_now.clone(),
diff --git a/cargo/switchyard/src/api/apply/util.rs b/cargo/switchyard/src/api/apply/util.rs
index 97222a8..2ee84bf 100644
--- a/cargo/switchyard/src/api/apply/util.rs
+++ b/cargo/switchyard/src/api/apply/util.rs
@@ -1,5 +1,7 @@
+use crate::api::DebugLockManager;
+
 pub(crate) fn lock_backend_label(
-    mgr: Option<&Box<dyn crate::adapters::lock::LockManager>>,
+    mgr: Option<&Box<dyn DebugLockManager>>,
 ) -> String {
     if let Some(m) = mgr {
         // Best-effort dynamic type name; map common implementations to concise labels
diff --git a/cargo/switchyard/src/api/builder.rs b/cargo/switchyard/src/api/builder.rs
index 2220d26..d19e0a6 100644
--- a/cargo/switchyard/src/api/builder.rs
+++ b/cargo/switchyard/src/api/builder.rs
@@ -1,22 +1,23 @@
-use crate::adapters::{Attestor, LockManager, OwnershipOracle, SmokeTestRunner};
+use crate::api::{DebugAttestor, DebugLockManager, DebugOwnershipOracle, DebugSmokeTestRunner};
 use crate::logging::{AuditSink, FactsEmitter};
 use crate::policy::Policy;
 use crate::constants::DEFAULT_LOCK_TIMEOUT_MS;
 
 /// Builder for constructing a Switchyard with ergonomic chaining.
 /// Mirrors `Switchyard::new(...).with_*` but avoids duplication at call sites.
+#[derive(Debug)]
 pub struct ApiBuilder<E: FactsEmitter, A: AuditSink> {
     facts: E,
     audit: A,
     policy: Policy,
     // Optional adapters/handles
-    lock: Option<Box<dyn LockManager>>,              // None in dev/test; required in production
-    owner: Option<Box<dyn OwnershipOracle>>,         // strict ownership gating
-    attest: Option<Box<dyn Attestor>>,               // final summary attestation
-    smoke: Option<Box<dyn SmokeTestRunner>>,         // post-apply health verification
+    lock: Option<Box<dyn DebugLockManager>>,              // None in dev/test; required in production
+    owner: Option<Box<dyn DebugOwnershipOracle>>,         // strict ownership gating
+    attest: Option<Box<dyn DebugAttestor>>,               // final summary attestation
+    smoke: Option<Box<dyn DebugSmokeTestRunner>>,         // post-apply health verification
     lock_timeout_ms: Option<u64>,
 }
-
+    
 impl<E: FactsEmitter, A: AuditSink> ApiBuilder<E, A> {
     pub fn new(facts: E, audit: A, policy: Policy) -> Self {
         Self {
@@ -64,22 +65,22 @@ impl<E: FactsEmitter, A: AuditSink> ApiBuilder<E, A> {
         api
     }
 
-    pub fn with_lock_manager(mut self, lock: Box<dyn LockManager>) -> Self {
+    pub fn with_lock_manager(mut self, lock: Box<dyn DebugLockManager>) -> Self {
         self.lock = Some(lock);
         self
     }
 
-    pub fn with_ownership_oracle(mut self, owner: Box<dyn OwnershipOracle>) -> Self {
+    pub fn with_ownership_oracle(mut self, owner: Box<dyn DebugOwnershipOracle>) -> Self {
         self.owner = Some(owner);
         self
     }
 
-    pub fn with_attestor(mut self, attest: Box<dyn Attestor>) -> Self {
+    pub fn with_attestor(mut self, attest: Box<dyn DebugAttestor>) -> Self {
         self.attest = Some(attest);
         self
     }
 
-    pub fn with_smoke_runner(mut self, smoke: Box<dyn SmokeTestRunner>) -> Self {
+    pub fn with_smoke_runner(mut self, smoke: Box<dyn DebugSmokeTestRunner>) -> Self {
         self.smoke = Some(smoke);
         self
     }
diff --git a/cargo/switchyard/src/api/errors.rs b/cargo/switchyard/src/api/errors.rs
index 66979d8..be7dd7b 100644
--- a/cargo/switchyard/src/api/errors.rs
+++ b/cargo/switchyard/src/api/errors.rs
@@ -69,7 +69,7 @@ impl From<crate::types::errors::Error> for ApiError {
 
 // Stable identifiers aligned with SPEC/error_codes.toml
 // We intentionally keep SCREAMING_SNAKE_CASE to match emitted IDs.
-#[allow(non_camel_case_types)]
+#[allow(non_camel_case_types, reason = "Error IDs must match SPEC/error_codes.toml format")]
 #[derive(Clone, Copy, Debug)]
 pub enum ErrorId {
     E_POLICY,
diff --git a/cargo/switchyard/src/api/mod.rs b/cargo/switchyard/src/api/mod.rs
index 47c68c4..0984d00 100644
--- a/cargo/switchyard/src/api/mod.rs
+++ b/cargo/switchyard/src/api/mod.rs
@@ -31,14 +31,31 @@ pub use builder::ApiBuilder;
 /// DX alias for `ApiBuilder`.
 pub type SwitchyardBuilder<E, A> = ApiBuilder<E, A>;
 
+/// Trait for lock managers that can be debugged
+pub trait DebugLockManager: LockManager + std::fmt::Debug {}
+impl<T: LockManager + std::fmt::Debug> DebugLockManager for T {}
+
+/// Trait for ownership oracles that can be debugged
+pub trait DebugOwnershipOracle: OwnershipOracle + std::fmt::Debug {}
+impl<T: OwnershipOracle + std::fmt::Debug> DebugOwnershipOracle for T {}
+
+/// Trait for attestors that can be debugged
+pub trait DebugAttestor: Attestor + std::fmt::Debug {}
+impl<T: Attestor + std::fmt::Debug> DebugAttestor for T {}
+
+/// Trait for smoke test runners that can be debugged
+pub trait DebugSmokeTestRunner: SmokeTestRunner + std::fmt::Debug {}
+impl<T: SmokeTestRunner + std::fmt::Debug> DebugSmokeTestRunner for T {}
+
+#[derive(Debug)]
 pub struct Switchyard<E: FactsEmitter, A: AuditSink> {
     facts: E,
     audit: A,
     policy: Policy,
-    lock: Option<Box<dyn LockManager>>, // None in dev/test; required in production
-    owner: Option<Box<dyn OwnershipOracle>>, // for strict ownership gating
-    attest: Option<Box<dyn Attestor>>,  // for final summary attestation
-    smoke: Option<Box<dyn SmokeTestRunner>>, // for post-apply health verification
+    lock: Option<Box<dyn DebugLockManager>>, // None in dev/test; required in production
+    owner: Option<Box<dyn DebugOwnershipOracle>>, // for strict ownership gating
+    attest: Option<Box<dyn DebugAttestor>>,  // for final summary attestation
+    smoke: Option<Box<dyn DebugSmokeTestRunner>>, // for post-apply health verification
     lock_timeout_ms: u64,
 }
 
@@ -57,25 +74,25 @@ impl<E: FactsEmitter, A: AuditSink> Switchyard<E, A> {
     }
 
     /// Configure via `ApiBuilder::with_lock_manager`.
-    pub fn with_lock_manager(mut self, lock: Box<dyn LockManager>) -> Self {
+    pub fn with_lock_manager(mut self, lock: Box<dyn DebugLockManager>) -> Self {
         self.lock = Some(lock);
         self
     }
 
     /// Configure via `ApiBuilder::with_ownership_oracle`.
-    pub fn with_ownership_oracle(mut self, owner: Box<dyn OwnershipOracle>) -> Self {
+    pub fn with_ownership_oracle(mut self, owner: Box<dyn DebugOwnershipOracle>) -> Self {
         self.owner = Some(owner);
         self
     }
 
     /// Configure via `ApiBuilder::with_attestor`.
-    pub fn with_attestor(mut self, attest: Box<dyn Attestor>) -> Self {
+    pub fn with_attestor(mut self, attest: Box<dyn DebugAttestor>) -> Self {
         self.attest = Some(attest);
         self
     }
 
     /// Configure via `ApiBuilder::with_smoke_runner`.
-    pub fn with_smoke_runner(mut self, smoke: Box<dyn SmokeTestRunner>) -> Self {
+    pub fn with_smoke_runner(mut self, smoke: Box<dyn DebugSmokeTestRunner>) -> Self {
         self.smoke = Some(smoke);
         self
     }
@@ -132,7 +149,7 @@ impl<E: FactsEmitter, A: AuditSink> Switchyard<E, A> {
         let pid = uuid::Uuid::new_v5(&uuid::Uuid::NAMESPACE_URL, plan_like.as_bytes());
         let run_id = new_run_id();
         let tctx = crate::logging::audit::AuditCtx::new(
-            &self.facts as &dyn FactsEmitter,
+            &self.facts,
             pid.to_string(),
             run_id,
             crate::logging::redact::now_iso(),
diff --git a/cargo/switchyard/src/api/plan.rs b/cargo/switchyard/src/api/plan.rs
index 2cef37c..979554b 100644
--- a/cargo/switchyard/src/api/plan.rs
+++ b/cargo/switchyard/src/api/plan.rs
@@ -49,7 +49,7 @@ pub(crate) fn build<E: FactsEmitter, A: crate::logging::AuditSink>(
     let pid = pid_uuid.to_string();
     let run_id = new_run_id();
     let tctx = AuditCtx::new(
-        &api.facts as &dyn FactsEmitter,
+        &api.facts,
         pid.clone(),
         run_id,
         crate::logging::TS_ZERO.to_string(),
diff --git a/cargo/switchyard/src/api/preflight/mod.rs b/cargo/switchyard/src/api/preflight/mod.rs
index 2c5515f..719c509 100644
--- a/cargo/switchyard/src/api/preflight/mod.rs
+++ b/cargo/switchyard/src/api/preflight/mod.rs
@@ -30,7 +30,7 @@ pub(crate) fn run<E: FactsEmitter, A: crate::logging::AuditSink>(
     let pid = plan_id(plan);
     let run_id = new_run_id();
     let ctx = AuditCtx::new(
-        &api.facts as &dyn FactsEmitter,
+        &api.facts,
         pid.to_string(),
         run_id,
         TS_ZERO.to_string(),
diff --git a/cargo/switchyard/src/fs/backup/prune.rs b/cargo/switchyard/src/fs/backup/prune.rs
index 92f0107..46e357c 100644
--- a/cargo/switchyard/src/fs/backup/prune.rs
+++ b/cargo/switchyard/src/fs/backup/prune.rs
@@ -78,7 +78,7 @@ pub fn prune_backups(
         .duration_since(UNIX_EPOCH)
         .unwrap_or_default()
         .as_millis();
-    let age_cutoff_ms: Option<u128> = age_limit.map(|d| d.as_millis() as u128);
+    let age_cutoff_ms: Option<u128> = age_limit.map(|d| d.as_millis());
 
     // Determine how many newest to retain by count policy.
     // We never delete the newest, so clamp minimum to 1.
diff --git a/cargo/switchyard/src/fs/backup/snapshot.rs b/cargo/switchyard/src/fs/backup/snapshot.rs
index 05bf108..a2e3845 100644
--- a/cargo/switchyard/src/fs/backup/snapshot.rs
+++ b/cargo/switchyard/src/fs/backup/snapshot.rs
@@ -178,7 +178,7 @@ mod tests {
         let t = tmp();
         let root = t.path();
         let tgt = root.join("file.txt");
-        std::fs::write(&tgt, b"hello").unwrap();
+        fs::write(&tgt, b"hello").unwrap();
         create_snapshot(&tgt, DEFAULT_BACKUP_TAG).unwrap();
         let pair = index::find_latest_backup_and_sidecar(&tgt, DEFAULT_BACKUP_TAG).expect("pair");
         assert!(pair.0.is_some(), "payload present");
@@ -190,10 +190,10 @@ mod tests {
         let t = tmp();
         let root = t.path();
         let target = root.join("bin");
-        std::fs::create_dir_all(&target).unwrap();
+        fs::create_dir_all(&target).unwrap();
         let link = root.join("usr/bin/app");
-        std::fs::create_dir_all(link.parent().unwrap()).unwrap();
-        let _ = std::os::unix::fs::symlink("../../bin", &link); // relative symlink
+        fs::create_dir_all(link.parent().unwrap()).unwrap();
+        let _ = unix::fs::symlink("../../bin", &link); // relative symlink
         create_snapshot(&link, DEFAULT_BACKUP_TAG).unwrap();
         let pair = index::find_latest_backup_and_sidecar(&link, DEFAULT_BACKUP_TAG).expect("pair");
         assert!(pair.1.exists(), "sidecar exists");
diff --git a/cargo/switchyard/src/fs/mount.rs b/cargo/switchyard/src/fs/mount.rs
index f9b3b53..89d597a 100644
--- a/cargo/switchyard/src/fs/mount.rs
+++ b/cargo/switchyard/src/fs/mount.rs
@@ -8,6 +8,7 @@ pub trait MountInspector {
 }
 
 /// Production inspector. Prefer kernel syscalls when available; fall back to parsing /proc/self/mounts.
+#[derive(Debug, Copy, Clone)]
 pub struct ProcStatfsInspector;
 
 impl ProcStatfsInspector {
diff --git a/cargo/switchyard/src/fs/restore/engine.rs b/cargo/switchyard/src/fs/restore/engine.rs
index 8dbaf4f..bac3404 100644
--- a/cargo/switchyard/src/fs/restore/engine.rs
+++ b/cargo/switchyard/src/fs/restore/engine.rs
@@ -49,9 +49,8 @@ pub fn restore_impl(target: &SafePath, sel: SnapshotSel, opts: &RestoreOptions)
         None => {
             if !opts.force_best_effort {
                 return Err(std::io::Error::new(std::io::ErrorKind::NotFound, "backup missing"));
-            } else {
-                return Ok(());
             }
+            return Ok(());
         }
     };
     // Read sidecar if present
diff --git a/cargo/switchyard/src/fs/restore/steps.rs b/cargo/switchyard/src/fs/restore/steps.rs
index e26c4e5..28494cd 100644
--- a/cargo/switchyard/src/fs/restore/steps.rs
+++ b/cargo/switchyard/src/fs/restore/steps.rs
@@ -87,6 +87,7 @@ pub fn restore_symlink_to(target_path: &Path, dest: &Path) -> std::io::Result<()
 }
 
 #[cfg(test)]
+#[allow(clippy::unwrap_used, clippy::expect_used, clippy::panic)]
 mod tests {
     use super::*;
 
diff --git a/cargo/switchyard/src/fs/swap.rs b/cargo/switchyard/src/fs/swap.rs
index 23a2f24..15ec715 100644
--- a/cargo/switchyard/src/fs/swap.rs
+++ b/cargo/switchyard/src/fs/swap.rs
@@ -133,6 +133,7 @@ pub fn replace_file_with_symlink(
 }
 
 #[cfg(test)]
+#[allow(clippy::panic)]
 mod tests {
     use super::*;
     use crate::constants::DEFAULT_BACKUP_TAG;
@@ -140,7 +141,7 @@ mod tests {
     use crate::types::safepath::SafePath;
 
     fn tmpdir() -> tempfile::TempDir {
-        tempfile::tempdir().expect("tempdir")
+        tempfile::tempdir().unwrap_or_else(|_| panic!("Failed to create tempdir"))
     }
 
     #[test]
@@ -151,20 +152,20 @@ mod tests {
         let tgt = root.join("target.txt");
 
         // Create source file
-        std::fs::write(&src, b"hello").unwrap();
+        fs::write(&src, b"hello").expect("Failed to write source file");
 
         // SafePaths
-        let sp_src = SafePath::from_rooted(root, &src).unwrap();
-        let sp_tgt = SafePath::from_rooted(root, &tgt).unwrap();
+        let sp_src = SafePath::from_rooted(root, &src).expect("Failed to create source SafePath");
+        let sp_tgt = SafePath::from_rooted(root, &tgt).expect("Failed to create target SafePath");
 
         // Perform atomic swap: create symlink at target -> source
-        let _ =
-            replace_file_with_symlink(&sp_src, &sp_tgt, false, false, DEFAULT_BACKUP_TAG).unwrap();
+        let _ = replace_file_with_symlink(&sp_src, &sp_tgt, false, false, DEFAULT_BACKUP_TAG)
+            .expect("Failed to replace file with symlink");
 
         // Verify target is a symlink pointing to source
-        let md = std::fs::symlink_metadata(&tgt).unwrap();
+        let md = fs::symlink_metadata(&tgt).expect("Failed to get symlink metadata");
         assert!(md.file_type().is_symlink(), "target should be a symlink");
-        let link = std::fs::read_link(&tgt).unwrap();
+        let link = fs::read_link(&tgt).expect("Failed to read symlink");
         assert_eq!(link, src);
     }
 
@@ -176,33 +177,32 @@ mod tests {
         let tgt = root.join("bin-old");
 
         // Create source and target files
-        std::fs::write(&src, b"new").unwrap();
+        fs::write(&src, b"new").unwrap_or_else(|e| panic!("Failed to write source file: {e}"));
         {
-            let mut f = std::fs::File::create(&tgt).unwrap();
-            use std::io::Write as _;
-            writeln!(f, "old").unwrap();
+            let mut f = fs::File::create(&tgt).unwrap_or_else(|e| panic!("Failed to create target file: {e}"));
+            writeln!(f, "old").unwrap_or_else(|e| panic!("Failed to write to target file: {e}"));
         }
 
-        let sp_src = SafePath::from_rooted(root, &src).unwrap();
-        let sp_tgt = SafePath::from_rooted(root, &tgt).unwrap();
+        let sp_src = SafePath::from_rooted(root, &src).unwrap_or_else(|e| panic!("Failed to create source SafePath: {e}"));
+        let sp_tgt = SafePath::from_rooted(root, &tgt).unwrap_or_else(|e| panic!("Failed to create target SafePath: {e}"));
 
         // Replace target with symlink to source; backup should be created
-        let _ =
-            replace_file_with_symlink(&sp_src, &sp_tgt, false, false, DEFAULT_BACKUP_TAG).unwrap();
-        let md = std::fs::symlink_metadata(&tgt).unwrap();
+        let _ = replace_file_with_symlink(&sp_src, &sp_tgt, false, false, DEFAULT_BACKUP_TAG)
+            .unwrap_or_else(|e| panic!("Failed to replace file with symlink: {e}"));
+        let md = fs::symlink_metadata(&tgt).unwrap_or_else(|e| panic!("Failed to get symlink metadata: {e}"));
         assert!(
             md.file_type().is_symlink(),
             "target should be a symlink after replace"
         );
 
         // Restore from backup; target should be a regular file again with prior content prefix
-        restore_file(&sp_tgt, false, false, DEFAULT_BACKUP_TAG).unwrap();
-        let md2 = std::fs::symlink_metadata(&tgt).unwrap();
+        restore_file(&sp_tgt, false, false, DEFAULT_BACKUP_TAG).unwrap_or_else(|e| panic!("Failed to restore file: {e}"));
+        let md2 = fs::symlink_metadata(&tgt).unwrap_or_else(|e| panic!("Failed to get symlink metadata: {e}"));
         assert!(
             md2.file_type().is_file(),
             "target should be a regular file after restore"
         );
-        let content = std::fs::read_to_string(&tgt).unwrap();
+        let content = fs::read_to_string(&tgt).unwrap_or_else(|e| panic!("Failed to read target file: {e}"));
         assert!(content.starts_with("old"));
     }
 }
diff --git a/cargo/switchyard/src/lib.rs b/cargo/switchyard/src/lib.rs
index e7ff9c6..e4f61a1 100644
--- a/cargo/switchyard/src/lib.rs
+++ b/cargo/switchyard/src/lib.rs
@@ -1,4 +1,4 @@
-#![forbid(unsafe_code)]
+#![deny(unsafe_code)]
 
 /* ---- unwrap/expect policy ---- */
 // Warn everywhere (incl. tests), but deny in non-test builds.
diff --git a/cargo/switchyard/src/logging/audit.rs b/cargo/switchyard/src/logging/audit.rs
index 6656b87..b69ce47 100644
--- a/cargo/switchyard/src/logging/audit.rs
+++ b/cargo/switchyard/src/logging/audit.rs
@@ -23,6 +23,7 @@ pub(crate) struct AuditMode {
     pub redact: bool,
 }
 
+#[derive(Debug)]
 pub(crate) struct AuditCtx<'a> {
     pub facts: &'a dyn FactsEmitter,
     pub plan_id: String,
@@ -98,6 +99,7 @@ impl Decision {
 }
 
 /// Builder facade over audit emission with centralized envelope+redaction.
+#[derive(Debug)]
 pub struct StageLogger<'a> {
     ctx: &'a AuditCtx<'a>,
 }
@@ -115,6 +117,7 @@ impl<'a> StageLogger<'a> {
     pub fn prune_result(&'a self) -> EventBuilder<'a> { EventBuilder::new(self.ctx, Stage::PruneResult) }
 }
 
+#[derive(Debug)]
 pub struct EventBuilder<'a> {
     ctx: &'a AuditCtx<'a>,
     stage: Stage,
@@ -206,15 +209,18 @@ fn redact_and_emit(
             }
             // process
             if let Entry::Vacant(e) = obj.entry("process".to_string()) {
-                let pid = std::process::id() as u32;
-                let ppid = unsafe { libc::getppid() as u32 };
-                e.insert(json!({"pid": pid, "ppid": ppid}));
+                let process_id = std::process::id();
+                #[allow(unsafe_code, reason = "libc::getppid() requires unsafe block")]
+                let parent_process_id = unsafe { libc::getppid() };
+                e.insert(json!({"pid": process_id, "ppid": parent_process_id}));
             }
             // actor (effective ids)
             if let Entry::Vacant(e) = obj.entry("actor".to_string()) {
-                let euid = unsafe { libc::geteuid() } as u32;
-                let egid = unsafe { libc::getegid() } as u32;
-                e.insert(json!({"euid": euid, "egid": egid}));
+                #[allow(unsafe_code, reason = "libc::geteuid() requires unsafe block")]
+                let effective_user_id = unsafe { libc::geteuid() };
+                #[allow(unsafe_code, reason = "libc::getegid() requires unsafe block")]
+                let effective_group_id = unsafe { libc::getegid() };
+                e.insert(json!({"euid": effective_user_id, "egid": effective_group_id}));
             }
             // build
             if let Entry::Vacant(e) = obj.entry("build".to_string()) {
diff --git a/cargo/switchyard/src/logging/facts.rs b/cargo/switchyard/src/logging/facts.rs
index a0ea631..942140f 100644
--- a/cargo/switchyard/src/logging/facts.rs
+++ b/cargo/switchyard/src/logging/facts.rs
@@ -1,7 +1,7 @@
 use log::Level;
 use serde_json::Value;
 
-pub trait FactsEmitter {
+pub trait FactsEmitter: std::fmt::Debug {
     fn emit(&self, subsystem: &str, event: &str, decision: &str, fields: Value);
 }
 
@@ -10,6 +10,7 @@ pub trait AuditSink {
 }
 
 #[derive(Default)]
+#[derive(Debug, Copy, Clone)]
 pub struct JsonlSink;
 
 impl FactsEmitter for JsonlSink {
@@ -23,7 +24,7 @@ impl AuditSink for JsonlSink {
 // Optional: file-backed JSONL sink for production integration.
 // Enabled via `--features file-logging`.
 #[cfg(feature = "file-logging")]
-#[derive(Clone)]
+#[derive(Debug, Clone)]
 pub struct FileJsonlSink {
     path: std::path::PathBuf,
 }
@@ -55,10 +56,10 @@ impl FactsEmitter for FileJsonlSink {
         // Merge subsystem/event/decision into the JSON object if it's an object; otherwise, wrap.
         let out = match fields {
             Value::Object(mut m) => {
-                m.entry("subsystem".into())
+                m.entry("subsystem".to_string())
                     .or_insert(Value::from(subsystem));
-                m.entry("event".into()).or_insert(Value::from(event));
-                m.entry("decision".into()).or_insert(Value::from(decision));
+                m.entry("event".to_string()).or_insert(Value::from(event));
+                m.entry("decision".to_string()).or_insert(Value::from(decision));
                 Value::Object(m)
             }
             other => serde_json::json!({
diff --git a/cargo/switchyard/src/logging/redact.rs b/cargo/switchyard/src/logging/redact.rs
index 83edd38..10feb09 100644
--- a/cargo/switchyard/src/logging/redact.rs
+++ b/cargo/switchyard/src/logging/redact.rs
@@ -11,46 +11,6 @@ pub fn now_iso() -> String {
         .unwrap_or_else(|_| TS_ZERO.to_string())
 }
 
-#[cfg(test)]
-mod tests {
-    use super::*;
-    use serde_json::json;
-
-    #[test]
-    fn redact_masks_and_removes_expected_fields() {
-        let input = json!({
-            "ts": "2025-01-01T12:00:00Z",
-            "duration_ms": 123,
-            "lock_wait_ms": 45,
-            "severity": "warn",
-            "degraded": true,
-            "before_hash": "abc",
-            "after_hash": "def",
-            "hash_alg": "sha256",
-            "provenance": {"helper":"paru", "uid": 0, "gid": 0, "pkg": "coreutils"},
-            "attestation": {"signature":"sig","bundle_hash":"bh","public_key_id":"pk"}
-        });
-        let out = redact_event(input);
-        assert_eq!(out.get("ts").and_then(|v| v.as_str()), Some(TS_ZERO));
-        assert!(out.get("duration_ms").is_none());
-        assert!(out.get("lock_wait_ms").is_none());
-        assert!(out.get("severity").is_none());
-        assert!(out.get("degraded").is_none());
-        assert!(out.get("before_hash").is_none());
-        assert!(out.get("after_hash").is_none());
-        assert!(out.get("hash_alg").is_none());
-        let prov = out.get("provenance").and_then(|v| v.as_object()).unwrap();
-        assert_eq!(prov.get("helper").and_then(|v| v.as_str()), Some("***"));
-        let att = out.get("attestation").and_then(|v| v.as_object()).unwrap();
-        assert_eq!(att.get("signature").and_then(|v| v.as_str()), Some("***"));
-        assert_eq!(att.get("bundle_hash").and_then(|v| v.as_str()), Some("***"));
-        assert_eq!(
-            att.get("public_key_id").and_then(|v| v.as_str()),
-            Some("***")
-        );
-    }
-}
-
 /// Return a timestamp for facts emission based on mode.
 /// - DryRun: constant zero timestamp for determinism.
 /// - Commit: real, current timestamp in RFC3339.
@@ -102,3 +62,44 @@ pub fn redact_event(mut v: Value) -> Value {
     }
     v
 }
+
+#[cfg(test)]
+#[allow(clippy::panic)]
+mod tests {
+    use super::*;
+    use serde_json::json;
+
+    #[test]
+    fn redact_masks_and_removes_expected_fields() {
+        let input = json!({
+            "ts": "2025-01-01T12:00:00Z",
+            "duration_ms": 123,
+            "lock_wait_ms": 45,
+            "severity": "warn",
+            "degraded": true,
+            "before_hash": "abc",
+            "after_hash": "def",
+            "hash_alg": "sha256",
+            "provenance": {"helper":"paru", "uid": 0, "gid": 0, "pkg": "coreutils"},
+            "attestation": {"signature":"sig","bundle_hash":"bh","public_key_id":"pk"}
+        });
+        let out = redact_event(input);
+        assert_eq!(out.get("ts").and_then(|v| v.as_str()), Some(TS_ZERO));
+        assert!(out.get("duration_ms").is_none());
+        assert!(out.get("lock_wait_ms").is_none());
+        assert!(out.get("severity").is_none());
+        assert!(out.get("degraded").is_none());
+        assert!(out.get("before_hash").is_none());
+        assert!(out.get("after_hash").is_none());
+        assert!(out.get("hash_alg").is_none());
+        let prov = out.get("provenance").and_then(|v| v.as_object()).unwrap_or_else(|| panic!("provenance should be an object"));
+        assert_eq!(prov.get("helper").and_then(|v| v.as_str()), Some("***"));
+        let att = out.get("attestation").and_then(|v| v.as_object()).unwrap_or_else(|| panic!("attestation should be an object"));
+        assert_eq!(att.get("signature").and_then(|v| v.as_str()), Some("***"));
+        assert_eq!(att.get("bundle_hash").and_then(|v| v.as_str()), Some("***"));
+        assert_eq!(
+            att.get("public_key_id").and_then(|v| v.as_str()),
+            Some("***")
+        );
+    }
+}
diff --git a/cargo/switchyard/src/policy/gating.rs b/cargo/switchyard/src/policy/gating.rs
index e8e7376..60de2e4 100644
--- a/cargo/switchyard/src/policy/gating.rs
+++ b/cargo/switchyard/src/policy/gating.rs
@@ -1,7 +1,8 @@
-use crate::adapters::OwnershipOracle;
+use crate::api::DebugOwnershipOracle;
+use crate::types::plan::Action;
 use crate::policy::Policy;
 use crate::policy::types::{RiskLevel, SourceTrustPolicy};
-use crate::types::{Action, Plan};
+use crate::types::Plan;
 
 /// Centralized evaluation result for a single action under a given Policy.
 #[derive(Debug, Default, Clone)]
@@ -14,7 +15,7 @@ pub(crate) struct Evaluation {
 /// Evaluate policy gating for a single action.
 pub(crate) fn evaluate_action(
     policy: &Policy,
-    owner: Option<&dyn OwnershipOracle>,
+    owner: Option<&dyn DebugOwnershipOracle>,
     act: &Action,
 ) -> Evaluation {
     let mut stops: Vec<String> = Vec::new();
@@ -203,7 +204,7 @@ pub(crate) fn evaluate_action(
 /// This mirrors the gating performed in apply.rs before executing actions.
 pub(crate) fn gating_errors(
     policy: &Policy,
-    owner: Option<&dyn OwnershipOracle>,
+    owner: Option<&dyn DebugOwnershipOracle>,
     plan: &Plan,
 ) -> Vec<String> {
     let mut errs: Vec<String> = Vec::new();
diff --git a/cargo/switchyard/src/policy/rescue.rs b/cargo/switchyard/src/policy/rescue.rs
index fb9e42d..2722783 100644
--- a/cargo/switchyard/src/policy/rescue.rs
+++ b/cargo/switchyard/src/policy/rescue.rs
@@ -107,18 +107,18 @@ mod tests {
     #[test]
     #[serial]
     fn forced_ok_env_yields_ok() {
-        std::env::set_var("SWITCHYARD_FORCE_RESCUE_OK", "1");
+        env::set_var("SWITCHYARD_FORCE_RESCUE_OK", "1");
         let r = verify_rescue(false);
-        std::env::remove_var("SWITCHYARD_FORCE_RESCUE_OK");
+        env::remove_var("SWITCHYARD_FORCE_RESCUE_OK");
         assert!(r.is_ok());
     }
 
     #[test]
     #[serial]
     fn forced_fail_env_yields_err() {
-        std::env::set_var("SWITCHYARD_FORCE_RESCUE_OK", "0");
+        env::set_var("SWITCHYARD_FORCE_RESCUE_OK", "0");
         let r = verify_rescue(false);
-        std::env::remove_var("SWITCHYARD_FORCE_RESCUE_OK");
+        env::remove_var("SWITCHYARD_FORCE_RESCUE_OK");
         assert!(r.is_err());
     }
 }
diff --git a/cargo/switchyard/src/policy/types.rs b/cargo/switchyard/src/policy/types.rs
index bff57cd..dbc5789 100644
--- a/cargo/switchyard/src/policy/types.rs
+++ b/cargo/switchyard/src/policy/types.rs
@@ -48,7 +48,7 @@ pub struct Scope {
     pub forbid_paths: Vec<PathBuf>,
 }
 
-#[derive(Clone, Debug)]
+#[derive(Debug, Copy, Clone)]
 pub struct Rescue {
     pub require: bool,
     pub exec_check: bool,
@@ -61,7 +61,7 @@ impl Default for Rescue {
     }
 }
 
-#[derive(Clone, Debug)]
+#[derive(Debug, Copy, Clone)]
 pub struct Risks {
     pub suid_sgid: RiskLevel,
     pub hardlinks: RiskLevel,
@@ -75,7 +75,7 @@ impl Default for Risks {
     }
 }
 
-#[derive(Clone, Debug)]
+#[derive(Debug, Copy, Clone)]
 pub struct Durability {
     pub backup_durability: bool,
     pub sidecar_integrity: bool,
@@ -97,7 +97,7 @@ pub struct ApplyFlow {
     pub capture_restore_snapshot: bool,
 }
 
-#[derive(Clone, Debug)]
+#[derive(Debug, Copy, Clone)]
 pub struct Governance {
     pub locking: LockingPolicy,
     pub smoke: SmokePolicy,
diff --git a/cargo/switchyard/src/preflight/checks.rs b/cargo/switchyard/src/preflight/checks.rs
index b98619b..d738733 100644
--- a/cargo/switchyard/src/preflight/checks.rs
+++ b/cargo/switchyard/src/preflight/checks.rs
@@ -93,7 +93,7 @@ pub fn check_immutable(path: &Path) -> Result<(), String> {
 /// Source trust checks. Returns Err(String) if untrusted and `force` is false. When `force` is true,
 /// returns Ok(()) and leaves it to callers to emit warnings.
 pub fn check_source_trust(source: &Path, force: bool) -> Result<(), String> {
-    let meta = fs::symlink_metadata(source).map_err(|e| format!("{}", e))?;
+    let meta = fs::symlink_metadata(source).map_err(|e| format!("{e}"))?;
     let mode = meta.mode();
     if (mode & 0o002) != 0 && !force {
         return Err(format!(
diff --git a/cargo/switchyard/src/types/errors.rs b/cargo/switchyard/src/types/errors.rs
index 4716a88..7233f54 100644
--- a/cargo/switchyard/src/types/errors.rs
+++ b/cargo/switchyard/src/types/errors.rs
@@ -1,6 +1,6 @@
 use thiserror::Error;
 
-#[derive(Debug, Error)]
+#[derive(Debug, Copy, Clone, Error)]
 pub enum ErrorKind {
     #[error("invalid path")]
     InvalidPath,
diff --git a/cargo/switchyard/src/types/mount.rs b/cargo/switchyard/src/types/mount.rs
index be1597a..8f895ec 100644
--- a/cargo/switchyard/src/types/mount.rs
+++ b/cargo/switchyard/src/types/mount.rs
@@ -12,7 +12,7 @@ pub struct MountFlags {
 
 /// Error types for mount operations.
 /// Centralized under `crate::types` for cross-layer reuse.
-#[derive(Debug, thiserror::Error, Clone)]
+#[derive(Debug, Copy, Clone, thiserror::Error)]
 pub enum MountError {
     /// Unknown or ambiguous mount state
     #[error("unknown or ambiguous mount state")]
diff --git a/cargo/switchyard/src/types/plan.rs b/cargo/switchyard/src/types/plan.rs
index 60d14d6..6109a38 100644
--- a/cargo/switchyard/src/types/plan.rs
+++ b/cargo/switchyard/src/types/plan.rs
@@ -1,6 +1,6 @@
 use super::safepath::SafePath;
 
-#[derive(Clone, Debug)]
+#[derive(Debug, Copy, Clone)]
 pub enum ApplyMode {
     DryRun,
     Commit,
diff --git a/cargo/switchyard/src/types/report.rs b/cargo/switchyard/src/types/report.rs
index 3854330..964cbd6 100644
--- a/cargo/switchyard/src/types/report.rs
+++ b/cargo/switchyard/src/types/report.rs
@@ -3,7 +3,6 @@ use uuid::Uuid;
 
 // Typed representation of a preflight report.
 /// Centralized under `crate::types` for cross-layer reuse.
-
 #[must_use]
 #[derive(Clone, Debug, Default)]
 pub struct PreflightReport {
@@ -19,7 +18,6 @@ pub struct PreflightReport {
 
 // Typed representation of an apply report.
 /// Centralized under `crate::types` for cross-layer reuse.
-
 #[must_use]
 #[derive(Clone, Debug, Default)]
 pub struct ApplyReport {
@@ -39,7 +37,6 @@ pub struct ApplyReport {
 
 /// Typed representation of a prune result.
 /// Centralized under `crate::types` for cross-layer reuse.
-
 #[must_use]
 #[derive(Clone, Copy, Debug, Default)]
 pub struct PruneResult {
diff --git a/cargo/switchyard/src/types/safepath.rs b/cargo/switchyard/src/types/safepath.rs
index 8c80d59..6b6cf30 100644
--- a/cargo/switchyard/src/types/safepath.rs
+++ b/cargo/switchyard/src/types/safepath.rs
@@ -28,7 +28,12 @@ impl SafePath {
     /// 
     /// * `Result<Self>` - A SafePath if the candidate is valid, or an error otherwise
     pub fn from_rooted(root: &Path, candidate: &Path) -> Result<Self> {
-        assert!(root.is_absolute(), "root must be absolute");
+        if !root.is_absolute() {
+            return Err(Error {
+                kind: ErrorKind::InvalidPath,
+                msg: "root must be absolute".into(),
+            });
+        }
         let effective = if candidate.is_absolute() {
             match candidate.strip_prefix(root) {
                 Ok(p) => p.to_path_buf(),
@@ -95,6 +100,7 @@ impl SafePath {
 }
 
 #[cfg(test)]
+#[allow(clippy::panic)]
 mod tests {
     use super::*;
     use std::path::Path;
@@ -109,7 +115,7 @@ mod tests {
     fn accepts_absolute_inside_root() {
         let root = Path::new("/tmp/root");
         let candidate = Path::new("/tmp/root/usr/bin/ls");
-        let sp = SafePath::from_rooted(root, candidate).expect("inside root");
+        let sp = SafePath::from_rooted(root, candidate).unwrap_or_else(|e| panic!("Failed to create SafePath for absolute path inside root: {e}"));
         assert!(sp.as_path().starts_with(root));
         assert_eq!(sp.rel(), Path::new("usr/bin/ls"));
     }
@@ -125,7 +131,7 @@ mod tests {
     fn normalizes_curdir_components() {
         let root = Path::new("/tmp/root");
         let candidate = Path::new("./usr/./bin/./ls");
-        let sp = SafePath::from_rooted(root, candidate).expect("normalize");
+        let sp = SafePath::from_rooted(root, candidate).unwrap_or_else(|e| panic!("Failed to create SafePath with normalized curdir components: {e}"));
         assert_eq!(sp.rel(), Path::new("usr/bin/ls"));
         assert_eq!(sp.as_path(), Path::new("/tmp/root/usr/bin/ls"));
     }
